######################################
# --- Day 13: Point of Incidence --- #
######################################

import AOCUtils

def get_reflections(pattern):
    reflections = []

    for test_reflection in range(len(pattern[0])-1):
        left_a, left_b = 0, test_reflection + 1
        right_b, right_a = test_reflection + 1, len(pattern[0])

        if left_b - left_a < right_a - right_b:
            right_a = right_b + (left_b - left_a)
        elif left_b - left_a > right_a - right_b:
            left_a = left_b - (right_a - right_b)

        if all(''.join(l[left_a:left_b]) == ''.join(reversed(l[right_b:right_a])) for l in pattern):
            reflections.append((test_reflection + 1, None))

    pattern = list(zip(*pattern))

    for test_reflection in range(len(pattern[0])-1):
        left_a, left_b = 0, test_reflection + 1
        right_b, right_a = test_reflection + 1, len(pattern[0])

        if left_b - left_a < right_a - right_b:
            right_a = right_b + (left_b - left_a)
        elif left_b - left_a > right_a - right_b:
            left_a = left_b - (right_a - right_b)

        if all(''.join(l[left_a:left_b]) == ''.join(reversed(l[right_b:right_a])) for l in pattern):
            reflections.append((None, test_reflection + 1))

    return reflections

######################################

raw_patterns = AOCUtils.load_input(13)

patterns = [l.splitlines() for l in '\n'.join(raw_patterns).split('\n\n')]

p1 = sum((r[0][0] or 0) + 100 * (r[0][1] or 0) for r in map(get_reflections, patterns))
AOCUtils.print_answer(1, p1)

p2 = 0
for pattern in patterns:
    original_symmetry = get_reflections(pattern)

    for i in range(len(pattern)):
        for j in range(len(pattern[0])):
            new_pattern = [list(l[:]) for l in pattern]
            new_pattern[i][j] = '#' if new_pattern[i][j] == '.' else '.'

            new_symmetry = get_reflections(new_pattern)

            if len(new_symmetry) != 0 and new_symmetry != original_symmetry:
                # If original reflection is still valid, ignore it
                if len(new_symmetry) > 1:
                    new_symmetry.remove(original_symmetry[0])
                p2 += (new_symmetry[0][0] or 0) + 100 * (new_symmetry[0][1] or 0)

# Answer will always be doubled, as each new reflection
# will be generated by two smudge positions
AOCUtils.print_answer(2, p2//2)

AOCUtils.print_time_taken()
